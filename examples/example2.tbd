import tbd.option.Option


const PI = 3.24259


struct Person {
	name: string,
	age: int,
}


enum Result<T, E> {
	Ok(T),
	Error(E),
}


enum List<T> {
	Empty,
	Node(T, List<T>),
}


fun new(size, f) {
	fun aux(size, acc) {
		match size {
			0 -> { acc },
			i -> { aux((size - 1), f(i) :: acc) },
		}
	}
	aux(size, [])
}


fun reverse(l) {
	fun aux(l, acc) {
		match l {
			[] -> { acc },
			hd :: tl -> { aux(tl, hd :: acc) },
		}
	}
  	aux(l, Empty)
}


fun fold(f, acc, l) {
	match l {
		[] -> { reverse(acc) },
		hd :: tl -> { fold(f, f(acc, hd), tl) },
	}
}


fun anon() {
	fun(a, b) { a + b }
}


fun zip(l1, l2) {
	fun aux(l1, l2, acc) {
		match (l1, l2) {
			([], []) -> { Ok(reverse(acc)) },
			(h1 :: t1, h2 :: t2) -> {
				aux(t1, t2, (h1, h2) :: acc)
			},
			_ -> { Error(()) },
		}
	}
	aux(l1, l2)
}


fun iter(f, l) {
	match l {
		[] -> { () },
		hd :: tl -> {
			f(hd);
			iter(f, tl)
		},
	}
}