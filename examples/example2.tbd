module List {
	type a list {
		Empty,
		Node of a * a list,
	}

	fun make f n {
		fun aux n acc {
			match n {
				0 -> acc,
				_ -> {
					let next = Node (f n, acc);
					aux (n - 1) next
				}
			}
		}
		aux n Empty
	}

	fun reverse l {
		fun aux l acc {
			match l {
				Empty -> acc,
				Node (hd, tl) -> aux tl (Node (hd, acc))
			}
		}
		aux l Empty
	}

	fun fold f acc l {
		match l {
			Empty -> acc,
			Node (hd, tl) -> {
				let acc = f acc hd;
				fold f acc tl
			}
		}
	}

	fun map f l {
		fun aux l acc {
			match l {
				Empty -> reverse acc,
				Node (hd, tl) -> {
					let next = Node (f hd, acc);
					aux tl next
				}
			}
		}
	}

	fun iter f l {
		match l {
			Empty -> (),
			Node (hd, tl) -> {
				f hd;
				iter f tl
			}
		}
	}
}

fun main () {
	let l = List.Empty;
	List.iter (fun x -> print_endline (string_of_int x)) l;
}