let IntList = module {
    type t =
        | Empty
        | Node of int * t

    let make f n = {
        let rec aux n acc = match n {
            0 -> acc,
            _ -> {
                let acc = Node (f n, acc);
                aux (n - 1) acc
            }
        };
        aux n Empty
    }

    let reverse l = {
        let rec aux l acc = match l {
            Empty -> acc,
            Node (h, t) -> aux t (Node (h, acc))
        };
        aux l Empty
    }

    let rec fold f acc l = match l {
        Empty -> acc,
        Node (h, t) -> fold f (f acc h) t
    }

    let map f l = {
        let rec aux l acc = match l {
            Empty -> reverse acc,
            Node (h, t) -> {
                let acc = Node (f h, acc);
                aux t acc
            }
        };
        aux l Empty
    }

    let rec iter f l = match l {
        Empty -> (),
        Node (h, t) -> {
            f h;
            iter f t
        }
    }
}

let String = module {
    let concat (a : string) (b : string) : string = @concat
}

let Io = module {
    let print (msg : string) : unit = @print
    let print_line msg = print (String.concat msg "\n")
}

type Printable = sig {
    type t
    val to_string (t : string) : string
}

let MakePrinter (M : Printable) = module {
    let print_line x = Io.print_line (M.to_string x)
}

let Int = module {
	type t = int
	let to_string = string_of_int
}

let IntPrinter = MakePrinter Int

let () = {
    let l = IntList.make (fun i -> i) 10;
    let r = IntList.reverse l;
    IntList.iter (fun x -> IntPrinter.print_line x) r
}