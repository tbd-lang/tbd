let IntList = module {
    type t =
        | Empty
        | Node of Int * t

    let make f n = {
        let rec aux n acc = match n {
            0 -> acc,
            _ -> {
                let acc = Node (f n, acc) in
                aux (n - 1) acc
            }
        };
        aux n Empty
    }

    let reverse l = {
        let rec aux l acc = match l {
            Empty -> acc,
            Node (h, t) -> aux t (Node (h, acc))
        };
        aux l Empty
    }

    let rec fold f acc l = match l {
        Empty -> acc,
        Node (h, t) -> fold f (f acc h) t
    }

    let map f l = {
        let rec aux l acc = match l {
            Empty -> reverse acc,
            Node (h, t) -> {
                let acc = Node (f h, acc) in
                aux t acc
            }
        };
        aux l Empty
    }

    let rec iter f l = match l {
        Empty -> (),
        Node (h, t) -> {
            f h;
            iter f t
        }
    }
}

let String = module {
    let concat (a : string) (b : string) : string = @concat
}

let Io = module {
    let print (msg : string) : unit = @print
    let print_line msg = print (String.concat msg "\n")
}

type Printable = sig {
    type t
    val to_string (t : string) : string
}

let MakePrinter (M : Printable) = module {
    let print_line x = Io.print_line (M.to_string x)
}

let Int = module {
	type t = int
	let to_string = string_of_int
}

let IntPrinter = MakePrinter Int

let () = {
    let l = IntList.make (fun i -> i) 10;
    let r = IntList.reverse l;
    IntList.iter (fun x -> IntPrinter.print_line x) r
}

let f x = if @int_equal x 0 then 0 else 100000

let g x = 
	if @int_equal x 0 then {
		let y = @add_int x 2;
		@add_int y 1000
	} else 12


let h x = 
	if @int_equal x 0 then {
		let y = @add_int x 2;
		@add_int y 1000
	} else {
		12
	}
		
		
let i x = 
	if @int_equal x 0 then 1000 else {
		12
	}