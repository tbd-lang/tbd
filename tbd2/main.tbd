module Int with
  fun to_string x = string_of_int x
end

module String with
  fun to_int s = int_of_string s
end

module List with
  type 'a list =
    | Empty
    | Node of 'a * 'a list

  fun reverse l =
    fun aux l acc =
      match l with
      | Empty -> acc
      | Node (hd, tl) -> aux tl (Node (hd, acc))
    in
    aux l Empty

  fun make f n =
    fun aux n' acc =
      match n' with
      | 0 -> acc
      | _ -> 
        let elem = f n' in
        aux (n' - 1) (Node (elem, acc))
    in
    aux n Empty

  fun fold f acc l =
    match l with
    | Empty -> acc
    | Node (hd, tl) -> fold f (f acc hd) tl

  fun print f l =
    fun aux l acc =
      match l with
      | Empty -> acc ^ "]"
      | Node (hd, Empty) -> aux Empty (acc ^ (f hd))
      | Node (hd, tl) -> aux tl (acc ^ (f hd) ^ ",")
    in 
    print_endline (aux l "[")

  fun map f l =
    fun aux l acc =
      match l with
      | Empty -> reverse acc
      | Node (hd, tl) -> 
        let next = f hd in
        aux tl (Node (next, acc))
    in
    aux l Empty

  fun iter f l =
    match l with
    | Empty -> ()
    | Node (hd, tl) -> f hd; iter f tl

  fun iteri f l =
    match l with
    | Empty -> ()
    | Node (hd, tl) -> f hd; iter f tl
end

module Io with
  fun print = Printf.printf
end

let () =
  let a = {1, 2, 3, 4} in
  Io.print "%d\n" a.(0);
  a.(0) <- 42;
  Io.print "%d\n" a.(0);

  let x = Array.make 50 0 in
  Array.iter (fun x -> Io.print "%d, " x) x;

  let l = List.make (fun i -> i) 10 in
  List.print (fun x -> Int.to_string x) l;

  let r = List.reverse l in
  List.print (fun x -> Int.to_string x) r;

  let x = List.fold (fun acc x -> acc + (x * 2)) 0 l in
  Io.print "%d\n" x;

  (* List.iter (fun x -> print_endline (Int.to_string x)) l; *)